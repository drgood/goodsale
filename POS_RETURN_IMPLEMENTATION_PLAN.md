# POS Return Processing with Shift Reconciliation\n\n## Overview\n\nImplementing returns directly in the POS system during an active shift with automatic tracking of:\n- Revenue adjustments (sales reduction)\n- Cash impact (on-hand decrease for cash refunds)\n- Expected vs. actual cash reconciliation\n- Detailed transaction audit trail\n\n---\n\n## Current State Analysis\n\n### Expected Cash Formula (Current)\n```javascript\nexpectedCash = startingCash + cashSales + cashSettlements\n```\n\n### Problem\n- No return handling\n- If cash return issued during shift, expectedCash stays high\n- Shift reconciliation fails (e.g., drawer has GH₵1,300 but expected GH₵1,500)\n\n### Solution\n```javascript\nexpectedCash = startingCash + cashSales + cashSettlements - cashReturns\n```\n\n---\n\n## Phase 1: Database Schema Updates\n\n### 1.1 Update `shifts` table\n\n```sql\n-- Add to shifts table:\nALTER TABLE shifts ADD COLUMN cash_returns numeric(10, 2) DEFAULT '0';\nALTER TABLE shifts ADD COLUMN return_adjustments numeric(10, 2) DEFAULT '0';\nALTER TABLE shifts ADD COLUMN cash_refunded_at timestamp;\n\n-- New fields track:\n-- cash_returns: Total cash returned to customers during shift\n-- return_adjustments: Post-shift returns affecting this shift's reconciliation\n-- cash_refunded_at: Last time a cash refund was processed in this shift\n```\n\n**In Drizzle schema** (`src/db/schema.ts`):\n```typescript\nexport const shifts = pgTable(\"shifts\", {\n  // ... existing fields\n  cashReturns: numeric(\"cash_returns\", { precision: 10, scale: 2 }).default(\"0\"),\n  returnAdjustments: numeric(\"return_adjustments\", { precision: 10, scale: 2 }).default(\"0\"),\n  cashRefundedAt: timestamp(\"cash_refunded_at\", { withTimezone: true }),\n});\n```\n\n### 1.2 Create `return_transactions` table\n\n```typescript\nexport const returnTransactions = pgTable(\"return_transactions\", {\n  id: uuid(\"id\").defaultRandom().primaryKey(),\n  returnId: uuid(\"return_id\").references(() => returns.id, { onDelete: \"cascade\" }),\n  shiftId: uuid(\"shift_id\").references(() => shifts.id, { onDelete: \"set null\" }),\n  tenantId: uuid(\"tenant_id\").references(() => tenants.id, { onDelete: \"cascade\" }).notNull(),\n  \n  // Transaction details\n  action: varchar(\"action\", { length: 50 }).notNull(), // 'return_created', 'return_approved', 'return_refunded'\n  refundMethod: varchar(\"refund_method\", { length: 50 }), // 'cash', 'store_credit', 'card', 'mobile'\n  refundAmount: numeric(\"refund_amount\", { precision: 10, scale: 2 }),\n  \n  // Who and when\n  processedBy: uuid(\"processed_by\").references(() => users.id, { onDelete: \"set null\" }),\n  processedAt: timestamp(\"processed_at\", { withTimezone: true }).defaultNow(),\n  \n  // Impact details\n  impactOnRevenue: numeric(\"impact_on_revenue\", { precision: 10, scale: 2 }), // -totalReturnAmount\n  impactOnCash: numeric(\"impact_on_cash\", { precision: 10, scale: 2 }), // -refundAmount (if cash)\n  impactOnExpectedCash: numeric(\"impact_on_expected_cash\", { precision: 10, scale: 2 }), // calculated\n  \n  // Reason/notes\n  reason: text(\"reason\"),\n  notes: text(\"notes\"),\n  \n  // Before/after snapshots\n  shiftDataBefore: jsonb(\"shift_data_before\"), // Snapshot of shift before return\n  shiftDataAfter: jsonb(\"shift_data_after\"), // Snapshot of shift after return\n  \n  createdAt: timestamp(\"created_at\", { withTimezone: true }).defaultNow(),\n});\n```\n\n---\n\n## Phase 2: Update API & Query Layer\n\n### 2.1 New Query Function: `processReturn` with Shift Impact\n\n```typescript\nexport async function processReturnWithShiftImpact(\n  returnId: string,\n  action: 'approve' | 'reject' | 'refund',\n  shiftId: string,\n  refundMethod?: string,\n  processedBy?: string\n) {\n  // 1. Get return details\n  const returnRecord = await getReturnById(returnId);\n  if (!returnRecord) throw new Error('Return not found');\n  \n  // 2. Get current shift\n  const shift = await getShiftById(shiftId);\n  if (!shift) throw new Error('Shift not found');\n  \n  // 3. Create transaction log BEFORE update\n  const shiftDataBefore = { ...shift };\n  \n  // 4. Calculate impact\n  let impactOnRevenue = 0;\n  let impactOnCash = 0;\n  let impactOnExpectedCash = 0;\n  \n  if (action === 'refund') {\n    impactOnRevenue = -returnRecord.totalReturnAmount;\n    \n    if (refundMethod === 'cash') {\n      impactOnCash = -returnRecord.refundAmount;\n      impactOnExpectedCash = -returnRecord.refundAmount;\n    }\n    // Store credit/card/mobile don't impact cash drawer\n  }\n  \n  // 5. Update return status\n  const updatedReturn = await updateReturn(returnId, {\n    status: action === 'refund' ? 'refunded' : action === 'approve' ? 'approved' : 'rejected',\n    refundMethod,\n    refundedAt: action === 'refund' ? new Date() : undefined,\n  });\n  \n  // 6. Update shift if refund during shift\n  if (action === 'refund' && shift.status === 'open') {\n    const newCashReturns = parseFloat(shift.cashReturns) + returnRecord.refundAmount;\n    const newExpectedCash = \n      parseFloat(shift.startingCash) + \n      parseFloat(shift.cashSales) + \n      parseFloat(shift.cashSettlements) - \n      newCashReturns;\n    \n    const updatedShift = await updateShift(shiftId, {\n      cashReturns: newCashReturns.toString(),\n      expectedCash: newExpectedCash.toString(),\n      cashRefundedAt: new Date(),\n    });\n    \n    // 7. Create audit transaction\n    await db.insert(schema.returnTransactions).values({\n      returnId,\n      shiftId,\n      tenantId: returnRecord.tenantId,\n      action: 'return_refunded',\n      refundMethod,\n      refundAmount: returnRecord.refundAmount.toString(),\n      processedBy: processedBy || null,\n      impactOnRevenue: impactOnRevenue.toString(),\n      impactOnCash: impactOnCash.toString(),\n      impactOnExpectedCash: impactOnExpectedCash.toString(),\n      shiftDataBefore: shiftDataBefore,\n      shiftDataAfter: updatedShift,\n      reason: returnRecord.reason || null,\n    });\n  }\n  \n  return {\n    return: updatedReturn,\n    shiftImpact: { impactOnRevenue, impactOnCash, impactOnExpectedCash }\n  };\n}\n```\n\n### 2.2 Update `POST /api/returns` Endpoint\n\n```typescript\nexport async function POST(request: Request) {\n  const session = await getServerSession(authOptions);\n  if (!session?.user.tenantId) return unauthorized();\n  \n  const body = await request.json();\n  const { saleId, customerId, reason, items, refundMethod, shiftId, createdDuringShift } = body;\n  \n  // ... validation\n  \n  // Get policy\n  const policy = await getReturnPolicyByTenant(session.user.tenantId);\n  \n  // Calculate amounts\n  const totalReturnAmount = items.reduce((sum: number, i: any) => sum + i.quantity * i.unitPrice, 0);\n  const restockingFeeAmount = policy ? (totalReturnAmount * policy.restockingFeePercent) / 100 : 0;\n  const refundAmount = totalReturnAmount - restockingFeeAmount;\n  \n  // Create return\n  const newReturn = await createReturn({\n    tenantId: session.user.tenantId,\n    saleId,\n    customerId: customerId || null,\n    requestedBy: session.user.id,\n    reason: reason || null,\n    totalReturnAmount,\n    restockingFeeAmount,\n    refundAmount,\n    items: items.map((item: any) => ({\n      productId: item.productId || null,\n      productName: item.productName,\n      quantity: item.quantity,\n      unitPrice: item.unitPrice,\n      returnAmount: item.quantity * item.unitPrice,\n      condition: item.condition || null\n    }))\n  });\n  \n  // If auto-approve during shift with store credit, process immediately\n  if (createdDuringShift && refundMethod === 'store_credit' && policy?.requiresApproval === false) {\n    await processReturnWithShiftImpact(\n      newReturn.id,\n      'refund',\n      shiftId,\n      'store_credit',\n      session.user.id\n    );\n  }\n  \n  return NextResponse.json(newReturn, { status: 201 });\n}\n```\n\n---\n\n## Phase 3: POS UI Implementation\n\n### 3.1 Add Return UI to POS Page\n\n**Location**: `src/app/(goodsale)/[tenant]/pos/page.tsx`\n\n**Add to imports**:\n```typescript\nimport { RotateCcw } from \"lucide-react\";\n```\n\n**Add to state**:\n```typescript\nconst [isReturnModalOpen, setIsReturnModalOpen] = useState(false);\nconst [selectedSaleForReturn, setSelectedSaleForReturn] = useState<Sale | null>(null);\nconst [returnItems, setReturnItems] = useState<Set<string>>(new Set());\nconst [returnReason, setReturnReason] = useState('');\nconst [returnRefundMethod, setReturnRefundMethod] = useState('store_credit'); // Default safe option\nconst [isProcessingReturn, setIsProcessingReturn] = useState(false);\n```\n\n**Add quick return button**:\n```typescript\n// In the cart section header, next to \"Settle Receivable\" button\n<Button variant=\"outline\" size=\"sm\" onClick={openQuickReturn}>\n  <RotateCcw className=\"mr-2 h-4 w-4\" />\n  Quick Return\n</Button>\n```\n\n**Implement handler**:\n```typescript\nconst openQuickReturn = () => {\n  if (!lastCompletedSale) {\n    toast({ \n      variant: 'destructive',\n      title: 'No Sale',\n      description: 'Complete a sale first to process a return.'\n    });\n    return;\n  }\n  \n  setSelectedSaleForReturn(lastCompletedSale);\n  setReturnItems(new Set());\n  setReturnReason('');\n  setReturnRefundMethod('store_credit'); // Safe default\n  setIsReturnModalOpen(true);\n};\n\nconst handleProcessReturn = async () => {\n  if (!selectedSaleForReturn || returnItems.size === 0) {\n    toast({ variant: 'destructive', title: 'Select Items', description: 'Choose at least one item to return.' });\n    return;\n  }\n  \n  if (!shiftContext?.activeShift) {\n    toast({ variant: 'destructive', title: 'No Active Shift', description: 'Return can only be processed during an active shift.' });\n    return;\n  }\n  \n  setIsProcessingReturn(true);\n  try {\n    const returnItems_array = selectedSaleForReturn.items\n      .filter(item => returnItems.has(item.productId))\n      .map(item => ({\n        productId: item.productId,\n        productName: item.productName,\n        quantity: item.quantity,\n        unitPrice: item.price,\n      }));\n    \n    const response = await fetch('/api/returns', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        saleId: selectedSaleForReturn.id,\n        customerId: selectedSaleForReturn.customerId,\n        reason: returnReason || null,\n        items: returnItems_array,\n        refundMethod: returnRefundMethod,\n        shiftId: shiftContext.activeShift.id,\n        createdDuringShift: true,\n      })\n    });\n    \n    if (!response.ok) throw new Error('Failed to create return');\n    \n    const returnRecord = await response.json();\n    \n    // Update shift context\n    if (returnRefundMethod === 'cash') {\n      shiftContext.processReturn?.(returnRecord);\n    }\n    \n    toast({\n      title: 'Return Created',\n      description: `Return processed. Refund: GH₵${returnRecord.refundAmount.toFixed(2)} via ${returnRefundMethod}`\n    });\n    \n    setIsReturnModalOpen(false);\n  } catch (error) {\n    toast({ \n      variant: 'destructive',\n      title: 'Error',\n      description: error instanceof Error ? error.message : 'Failed to process return'\n    });\n  } finally {\n    setIsProcessingReturn(false);\n  }\n};\n```\n\n### 3.2 Return Modal Component\n\n```typescript\n{/* Quick Return Modal */}\n<Dialog open={isReturnModalOpen} onOpenChange={setIsReturnModalOpen}>\n  <DialogContent className=\"sm:max-w-md max-h-[80vh] overflow-y-auto\">\n    <DialogHeader>\n      <DialogTitle>Quick Return</DialogTitle>\n      <DialogDescriptionComponent>\n        Process a return from the most recent sale\n      </DialogDescriptionComponent>\n    </DialogHeader>\n    \n    {selectedSaleForReturn && (\n      <div className=\"space-y-4\">\n        {/* Items Selection */}\n        <div className=\"space-y-2\">\n          <Label className=\"font-semibold\">Select Items to Return</Label>\n          <div className=\"border rounded-lg p-3 space-y-2 max-h-40 overflow-y-auto\">\n            {selectedSaleForReturn.items.map(item => (\n              <div key={item.productId} className=\"flex items-start gap-2\">\n                <Checkbox\n                  id={`return-${item.productId}`}\n                  checked={returnItems.has(item.productId)}\n                  onCheckedChange={() => {\n                    const updated = new Set(returnItems);\n                    if (updated.has(item.productId)) {\n                      updated.delete(item.productId);\n                    } else {\n                      updated.add(item.productId);\n                    }\n                    setReturnItems(updated);\n                  }}\n                />\n                <label htmlFor={`return-${item.productId}`} className=\"flex-1 text-sm cursor-pointer\">\n                  <p className=\"font-medium\">{item.productName}</p>\n                  <p className=\"text-muted-foreground\">\n                    {item.quantity} × GH₵{item.price.toFixed(2)} = GH₵{(item.quantity * item.price).toFixed(2)}\n                  </p>\n                </label>\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        {/* Refund Method - STORE CREDIT ONLY FOR POS */}\n        <div className=\"space-y-2 bg-amber-50 dark:bg-amber-950/20 p-3 rounded-lg border border-amber-200 dark:border-amber-900\">\n          <Label className=\"font-semibold text-sm\">Refund Method</Label>\n          <p className=\"text-sm text-muted-foreground\">During shift, returns are credited to customer balance for safety</p>\n          <div className=\"font-medium\">Store Credit (Safe)</div>\n          <p className=\"text-xs text-muted-foreground\">Customer balance will increase by return amount</p>\n        </div>\n        \n        {/* Reason */}\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"quick-return-reason\">Reason (Optional)</Label>\n          <Textarea\n            id=\"quick-return-reason\"\n            placeholder=\"e.g., Changed mind, Defective...\"\n            value={returnReason}\n            onChange={(e) => setReturnReason(e.target.value)}\n            rows={2}\n          />\n        </div>\n      </div>\n    )}\n    \n    <DialogFooter>\n      <Button variant=\"outline\" onClick={() => setIsReturnModalOpen(false)} disabled={isProcessingReturn}>\n        Cancel\n      </Button>\n      <Button onClick={handleProcessReturn} disabled={isProcessingReturn || returnItems.size === 0}>\n        {isProcessingReturn ? 'Processing...' : 'Process Return'}\n      </Button>\n    </DialogFooter>\n  </DialogContent>\n</Dialog>\n```\n\n---\n\n## Phase 4: Shift Reconciliation Views\n\n### 4.1 Active Shift Summary Component\n\nCreate new component: `src/components/shift-summary.tsx`\n\n```typescript\nexport function ShiftSummary({ shift }: { shift: Shift }) {\n  const expectedCashBreakdown = [\n    { label: 'Starting Cash', value: parseFloat(shift.startingCash), type: 'start' },\n    { label: 'Cash Sales', value: parseFloat(shift.cashSales), type: 'add' },\n    { label: 'Settlements (Cash)', value: parseFloat(shift.cashSettlements), type: 'add' },\n    { label: 'Cash Refunds (Returns)', value: -parseFloat(shift.cashReturns), type: 'subtract' },\n  ];\n  \n  const expectedCash = expectedCashBreakdown.reduce((sum, item) => sum + item.value, 0);\n  \n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>Expected Cash Calculation</CardTitle>\n        <CardDescription>How we calculated the expected cash in drawer</CardDescription>\n      </CardHeader>\n      <CardContent className=\"space-y-3\">\n        {expectedCashBreakdown.map((item, idx) => (\n          <div key={idx}>\n            <div className=\"flex justify-between items-center\">\n              <span className=\"text-sm\">{item.label}</span>\n              <span className={cn(\n                \"font-semibold\",\n                item.type === 'add' && \"text-green-600\",\n                item.type === 'subtract' && \"text-red-600\"\n              )}>\n                {item.type === 'subtract' ? '-' : '+'} GH₵{Math.abs(item.value).toFixed(2)}\n              </span>\n            </div>\n            {idx < expectedCashBreakdown.length - 1 && <Separator className=\"my-2\" />}\n          </div>\n        ))}\n        <div className=\"bg-slate-100 dark:bg-slate-900 p-3 rounded-lg mt-4\">\n          <div className=\"flex justify-between items-center\">\n            <span className=\"font-semibold\">Expected Cash in Drawer</span>\n            <span className=\"text-lg font-bold\">GH₵{expectedCash.toFixed(2)}</span>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n### 4.2 Close Shift & Reconcile View\n\nUpdate existing close shift modal to show breakdown:\n\n```typescript\n{/* In Close Shift Dialog */}\n<ShiftSummary shift={activeShift} />\n\n<div className=\"mt-4 space-y-2\">\n  <Label htmlFor=\"actual-cash\">Actual Cash in Drawer</Label>\n  <Input\n    id=\"actual-cash\"\n    type=\"number\"\n    step=\"0.01\"\n    value={actualCash}\n    onChange={(e) => setActualCash(e.target.value)}\n    placeholder=\"Count and enter amount\"\n  />\n</div>\n\n<div className={cn(\n  \"p-3 rounded-lg mt-4 border-2\",\n  variance === 0 && \"bg-green-50 dark:bg-green-950/20 border-green-200\",\n  variance !== 0 && \"bg-red-50 dark:bg-red-950/20 border-red-200\"\n)}>\n  <p className=\"text-sm text-muted-foreground\">Variance</p>\n  <p className={cn(\n    \"text-lg font-bold\",\n    variance === 0 && \"text-green-600\",\n    variance > 0 && \"text-red-600\",\n    variance < 0 && \"text-orange-600\"\n  )}>\n    {variance === 0 ? '✓ Balanced!' : `${variance > 0 ? 'Over' : 'Under'} by GH₵${Math.abs(variance).toFixed(2)}`}\n  </p>\n</div>\n```\n\n---\n\n## Phase 5: Shift Context Updates\n\nUpdate `src/components/shift-manager.tsx`:\n\n```typescript\ntype ShiftContextType = {\n    activeShift: Shift | null;\n    startShift: (startingCash: number) => Promise<void>;\n    closeShift: (actualCash: number) => Promise<void>;\n    addSale: (sale: Sale) => Promise<void>;\n    processReturn: (return: Return) => Promise<void>; // NEW\n};\n\n// New method in ShiftProvider\nconst processReturn = async (returnRecord: Return) => {\n    if (!activeShift) return;\n    \n    const updatedShift = { ...activeShift };\n    \n    if (returnRecord.refundMethod === 'cash') {\n        updatedShift.cashReturns += returnRecord.refundAmount;\n        updatedShift.expectedCash = \n            updatedShift.startingCash + \n            updatedShift.cashSales + \n            updatedShift.cashSettlements - \n            updatedShift.cashReturns;\n    }\n    \n    // Adjust sales (reduce if cash refund, leave if credit)\n    if (returnRecord.refundMethod === 'cash') {\n        updatedShift.cashSales -= returnRecord.refundAmount;\n    }\n    \n    // Update database\n    try {\n        await fetch('/api/shifts', {\n            method: 'PUT',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                id: updatedShift.id,\n                cashSales: updatedShift.cashSales,\n                cashReturns: updatedShift.cashReturns,\n                expectedCash: updatedShift.expectedCash\n            })\n        });\n        setActiveShift(updatedShift);\n    } catch (error) {\n        console.error('Error processing return:', error);\n    }\n};\n```\n\n---\n\n## Implementation Sequence\n\n1. **Database** (Phase 1)\n   - Update shifts schema\n   - Create return_transactions table\n   - Run migration\n\n2. **Backend** (Phase 2)\n   - Add query functions\n   - Update API endpoints\n   - Add transaction logging\n\n3. **UI** (Phase 3, 4)\n   - Add POS return modal\n   - Create shift summary component\n   - Update close shift view\n\n4. **Integration** (Phase 5)\n   - Update shift context\n   - Wire up handlers\n   - Test end-to-end\n\n---\n\n## Cash Reconciliation Example\n\n### Scenario\n```\nShift Start: GH₵500 cash float\nSale 1: GH₵200 (Cash) → Expected: GH₵700\nSale 2: GH₵300 (Cash) → Expected: GH₵1,000\nReturn 1: GH₵50 cash refund → Expected: GH₵950\nExpected Cash: GH₵950\nActual Cash Count: GH₵950\nVariance: ✓ Balanced\n```\n\n### Without Returns Feature (broken)\n```\nExpected Cash: GH₵1,000 (ignores return)\nActual Cash: GH₵950\nVariance: ❌ -GH₵50 (unexplained discrepancy!)\n```\n\n---\n\n## Audit Trail Example\n\n```json\n{\n  \"returnId\": \"ret-123\",\n  \"shiftId\": \"shift-456\",\n  \"action\": \"return_refunded\",\n  \"refundMethod\": \"cash\",\n  \"refundAmount\": 50.00,\n  \"processedBy\": \"user-789\",\n  \"impactOnRevenue\": -55.00,\n  \"impactOnCash\": -50.00,\n  \"impactOnExpectedCash\": -50.00,\n  \"shiftDataBefore\": {\n    \"cashSales\": 500.00,\n    \"cashReturns\": 0.00,\n    \"expectedCash\": 1000.00\n  },\n  \"shiftDataAfter\": {\n    \"cashSales\": 500.00,\n    \"cashReturns\": 50.00,\n    \"expectedCash\": 950.00\n  },\n  \"processedAt\": \"2025-11-05T17:30:00Z\"\n}\n```\n\n---\n\n## Key Decisions\n\n1. **Store Credit Only for POS Returns** (Initially)\n   - Safest approach during shift\n   - No cash handling risks\n   - Can add cash returns later with approval\n\n2. **Automatic Audit Logging**\n   - Every return creates transaction record\n   - Before/after shift snapshots\n   - Full traceability\n\n3. **Real-time Shift Updates**\n   - ExpectedCash updates immediately\n   - No delay in reconciliation\n   - Clear variance visibility\n\n4. **No Impact on Inventory Yet**\n   - Returns don't auto-restock (future feature)\n   - Manual inventory adjustment needed\n   - Can add auto-restock later\n"